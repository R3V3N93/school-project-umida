// Modified version of libeye's example : 'free aim.txt'

/*	kd:
	
	This allows shooting where your cursor is aimed. Keep in mind this
	will cause a desync in multiplayer.
	
	You can fix this by restricting the cursor to a certain fov value, like 90Â°
	which would be the 4:3 box in the screen centre (assuming you didn't zoom
	or anything).
	
	*/

class Harpoon : EventHandler {
	const turn_bound = 0.400;

	actor harpoon; // stores physical 3d harpoon
	
	vector2				cursor_pos;
	protected vector2				resolution;
	protected vector2				window_resolution;
	protected vector2				cursor_tl;
	protected vector2				cursor_br;
	protected TextureId				sprite_cursor;
	
	protected vector2				angle;
	protected double				min_vang;
	protected double				max_vang;
	
	protected Le_ProjScreen			proj;
	protected Le_GlScreen			gl_proj;
	protected Le_SwScreen			sw_proj;
	
	protected transient Cvar		cvar_renderer;
	protected bool					can_project;
	
	vector3 diff;
	
	vector3 CursorDirection () const 
	{
		return diff;
	}

	override void WorldThingSpawned(WorldEvent e)
	{
		if(e.Thing is 'HarpoonObj')
			self.harpoon = e.Thing;
	}
	
	override void WorldTick () 
	{
		PlayerInfo player	= players [consoleplayer];
		let po				= PlayerPawn(player.mo);
		
		if(!po) {
			return;
		}
		
		// kd: Sprite size should remain the same on all resolutions, so...
		window_resolution	= (Screen.GetWidth(), Screen.GetHeight());
		let window_aspect	= 1.0 * Screen.GetWidth() / max(1, Screen.GetHeight());
		resolution			= 720 * (window_aspect, 1);
		
		// kd: Till I figure out this ui data clearscope whatever mess.
		cursor_tl = (0, 0);
		cursor_br = window_resolution;
		
		// kd: Prepare for some deprojections. We'll at least find out if there
		// is something under the cursor.
		PrepareProjection();
		
		if(!proj) {
			return;
		}
		
		proj.CacheCustomResolution(window_resolution);
		proj.CacheFov(player.fov);
		proj.OrientForPlayer(player);
		proj.BeginDeprojection();
		diff = proj.DeprojectScreenToDiff(cursor_pos);

		proj.BeginProjection();

		if(harpoon)
		{
			//proj.ProjectActorPos(harpoon.pos);
			vector2 harpoonLoc = (Screen.GetWidth() / 2.0, Screen.GetHeight() / 6.0)//proj.ProjectToScreen();

			// distance between mouse and harpoon
			// if the distance is larger than a half diameter of a circle, shorten it.
			double dist = sqrt(abs(cursor_pos.x - harpoonLoc.x) ** 2 + abs(cursor_pos.y - harpoonLoc.y) ** 2);
			if(dist > Screen.GetHeight() / 10.8)
			{
				// 10.8 == 1080 / 100
				dist = Screen.GetHeight() / 10.8;
			}

			harpoon.angle = atan2(mouse.x - Screen.GetWidth() / 2.0, mouse.y - (Screen.GetHeight() / 2.0 - harpoonLoc.y));

			int c = cos(harpoon.angle);
			int s = sin(harpoon.angle);

			Vector3 harpoonFinalLoc = harpoonLoc + (dist * s, dist * c, 0);
			harpoon.SetOrigin(harpoonFinalLoc, true);
		}	
	}
	
	// kd: Same deal with the hitbox viewer to handle either render mode.
	override void OnRegister () 
	{
		sprite_cursor	= TexMan.CheckForTexture("graphics/harpooncursor.png", TexMan.type_any);
		gl_proj			= new("Le_GlScreen");
		sw_proj			= new("Le_SwScreen");
		cvar_renderer	= Cvar.GetCvar("vid_rendermode", players [consoleplayer]);
		PrepareProjection();
	}
	
	protected void PrepareProjection () 
	{
		if(cvar_renderer)
		switch(cvar_renderer.GetInt()) {
		default:
			proj		= gl_proj;
			min_vang	= -90;
			max_vang	= 90;
			break;
		case 0:
		case 1:
			proj		= sw_proj;
			min_vang	= -56;
			max_vang	= 56;
			break;
		}
		
		else {
			proj = gl_proj;
		}
		
		can_project	= proj != NULL;
	}
	
	override void PlayerEntered (PlayerEvent event) 
	{
		// kd: Just make sure we got that important info...
		WorldTick();
		cursor_pos = 0.5 * (cursor_tl + cursor_br);
	}
	
	// kd: Moves the mouse cursor.
	override bool InputProcess (InputEvent event) {
		
		// kd: I dunno why zs won't let me set cursor_pos directly.
		cursor_pos.x = clamp(
			cursor_pos.x + event.mousex,
			cursor_tl.x,
			cursor_br.x);
		cursor_pos.y = clamp(
			cursor_pos.y - 2.0 * event.mousey,
			cursor_tl.y,
			cursor_br.y);
		return false;
	}
	
	override void RenderOverlay (RenderEvent event) {
		let window_to_screen	= (
			resolution.x / window_resolution.x,
			resolution.y / window_resolution.y);
		
		let cursor_pos = (
			window_to_screen.x * cursor_pos.x,
			window_to_screen.y * cursor_pos.y);
		
		Screen.DrawTexture(
			sprite_cursor,
			true,
			cursor_pos.x,
			cursor_pos.y,
			DTA_KEEPRATIO,		true,
			DTA_VIRTUALWIDTHF,	resolution.x,
			DTA_VIRTUALHEIGHTF,	resolution.y);
	}
}